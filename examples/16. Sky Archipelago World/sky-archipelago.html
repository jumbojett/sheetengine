<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <style>
    .main{width:1000px; margin:50px auto 0 auto;line-height:1.5;font-family: sans-serif;}
    .header{font:38px sans-serif;margin-bottom:20px;}
    .subtitle{font:16px sans-serif;color:#666;margin-bottom:10px;}
    .code{margin:0px 40px 10px 40px;width:1000px;font-family:monospace;white-space: pre;background:#f5f5f5;padding:10px;}
    .content{margin:20px 0 60px;max-width:1000px;}
    #maincanvas{border:2px solid #333;background:#e8e8e8;display:block;margin:0 auto;}
    .stats{margin:10px 0;font-size:12px;color:#666;}
    .info{background:#f0f0f0;padding:15px;margin:20px 0;border-left:4px solid #4CAF50;}
  </style>
  <body>
    <script src="/dist/sheetengine.js"></script>
    
    <div class="main">
      <div class="header">
        üåç The Floating Sky Archipelago
      </div>
      
      <div class="subtitle">
        An interactive 3D isometric world with floating islands, structures, and characters
      </div>
      
      <canvas id="maincanvas" width="1000" height="600"></canvas>
      
      <div class="stats">
        <strong>Controls:</strong> Click to set character destination | Hover over structures to highlight | Watch the NPCs wander
      </div>
      
      <div class="info">
        <strong>üéÆ Features:</strong>
        <ul style="margin: 5px 0; padding-left: 20px;">
          <li>Multiple floating islands with varied terrain</li>
          <li>Interactive player character that pathfinds</li>
          <li>AI-controlled NPCs with wandering behavior</li>
          <li>Layered architecture with towers, walls, and decorations</li>
          <li>Dynamic lighting and shadows</li>
          <li>Interactive object selection with visual feedback</li>
          <li>Smooth animation and movement</li>
        </ul>
      </div>
      
      <div class="content">
        <h3>Scene Description</h3>
        <p>
          Welcome to the Floating Sky Archipelago! This interactive world showcases SheetEngine's capabilities for creating 
          detailed 3D isometric environments. The scene features multiple floating islands connected by bridges, each with 
          its own architecture and purpose. Navigate the player character by clicking on the terrain, interact with NPCs, 
          and explore the intricate structures that make up this sky realm.
        </p>
        
        <h3>Island Features</h3>
        <p>
          <strong>Central Hub:</strong> The main island with a central tower, marketplace, and defensive walls<br/>
          <strong>West Island:</strong> A quiet agricultural area with fields and a windmill<br/>
          <strong>East Island:</strong> A research tower with observation decks<br/>
          <strong>North Platform:</strong> A viewing platform overlooking the archipelago<br/>
          <strong>South Platform:</strong> A docking area for sky vessels
        </p>
      </div>
    </div>

    <script>
      var canvasElement = document.getElementById('maincanvas');
      sheetengine.scene.init(canvasElement, {w:1000,h:600});
      
      // Set a nice sky-themed background with gradient effect
      sheetengine.backgroundColor = '#B0E0E6'; // Powder blue for depth

      // ===== TERRAIN GENERATION =====
      
      // Main central island - large flat base with elevation
      function createIslandBase(centerX, centerY, sizeX, sizeY, baseColor, elevationLevels = 3) {
        const sheets = [];
        
        for (let level = 0; level < elevationLevels; level++) {
          const z = level * 20;
          const opacity = 1 - (level * 0.15);
          
          for (let x = -sizeX/2; x < sizeX/2; x += 100) {
            for (let y = -sizeY/2; y < sizeY/2; y += 100) {
              const basesheet = new sheetengine.BaseSheet(
                {x: centerX + x, y: centerY + y, z: z},
                {alphaD: 90, betaD: 0, gammaD: 0},
                {w: 100, h: 100}
              );
              
              // Gradient effect for depth
              const hsl = baseColor.replace('#', '');
              const r = parseInt(hsl.substring(0,2), 16);
              const g = parseInt(hsl.substring(2,4), 16);
              const b = parseInt(hsl.substring(4,6), 16);
              
              basesheet.color = '#' + [r-level*10, g-level*10, b-level*10].map(v => {
                const hex = Math.max(0, v).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
              }).join('');
            }
          }
        }
      }
      
      // Create islands
      createIslandBase(0, 0, 400, 400, '#4CAF50', 2);        // Central island (green)
      createIslandBase(-600, -300, 250, 250, '#8FBC8F', 2);  // West island (lighter green)
      createIslandBase(600, -300, 250, 250, '#1E90FF', 2);   // East island (blue)
      createIslandBase(0, 500, 200, 200, '#DAA520', 2);      // South platform (gold)
      createIslandBase(0, -500, 180, 180, '#C0C0C0', 2);     // North platform (silver)

      // ===== ARCHITECTURE FUNCTIONS =====
      
      function createTower(centerp, height, color, segments = 4) {
        const sheets = [];
        const segmentHeight = height / segments;
        
        for (let i = 0; i < segments; i++) {
          const z = i * segmentHeight + 20;
          
          const sheet = new sheetengine.Sheet(
            {x: centerp.x, y: centerp.y, z: z},
            {alphaD: 0, betaD: 0, gammaD: 0},
            {w: 40, h: 40}
          );
          sheet.context.fillStyle = color;
          sheet.context.fillRect(0, 0, 40, 40);
          
          // Add brickwork pattern
          sheet.context.strokeStyle = 'rgba(0,0,0,0.15)';
          sheet.context.lineWidth = 1;
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 4; col++) {
              sheet.context.strokeRect(col * 10, row * 5, 10, 5);
            }
          }
          
          // Windows with light effect
          sheet.context.fillStyle = i % 2 === 0 ? '#FFD700' : '#87CEEB';
          sheet.context.fillRect(5, 5, 6, 6);
          sheet.context.fillRect(19, 5, 6, 6);
          sheet.context.fillRect(5, 19, 6, 6);
          sheet.context.fillRect(19, 19, 6, 6);
          
          // Window frames
          sheet.context.strokeStyle = '#333';
          sheet.context.lineWidth = 1;
          sheet.context.strokeRect(5, 5, 6, 6);
          sheet.context.strokeRect(19, 5, 6, 6);
          sheet.context.strokeRect(5, 19, 6, 6);
          sheet.context.strokeRect(19, 19, 6, 6);
          
          sheets.push(sheet);
        }
        
        // Add flag on top
        const flagPos = {x: centerp.x, y: centerp.y - 10, z: height + 30};
        const flag = new sheetengine.Sheet(
          flagPos,
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 25, h: 18}
        );
        flag.context.fillStyle = '#FF4500';
        flag.context.fillRect(0, 0, 20, 12);
        flag.context.fillStyle = '#FFD700';
        flag.context.fillRect(2, 2, 5, 5);
        flag.context.fillStyle = '#333';
        flag.context.fillRect(18, 6, 7, 2);
        sheets.push(flag);
        
        return sheets;
      }
      
      function createWall(startPos, endPos, height, color) {
        const sheets = [];
        const segments = Math.ceil(Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2)) / 50);
        
        for (let i = 0; i < segments; i++) {
          const ratio = i / segments;
          const x = startPos.x + (endPos.x - startPos.x) * ratio;
          const y = startPos.y + (endPos.y - startPos.y) * ratio;
          
          const sheet = new sheetengine.Sheet(
            {x: x, y: y, z: 20},
            {alphaD: 0, betaD: 0, gammaD: 0},
            {w: 50, h: 30}
          );
          sheet.context.fillStyle = color;
          sheet.context.fillRect(0, 0, 50, 30);
          
          // Brickwork pattern
          sheet.context.strokeStyle = 'rgba(0,0,0,0.2)';
          sheet.context.lineWidth = 1;
          for (let row = 0; row < 6; row++) {
            for (let col = 0; col < 5; col++) {
              sheet.context.strokeRect(col * 10, row * 5, 10, 5);
            }
          }
          
          // Crenellations (battlements)
          sheet.context.fillStyle = color;
          sheet.context.fillRect(5, 0, 8, 8);
          sheet.context.fillRect(18, 0, 8, 8);
          sheet.context.fillRect(31, 0, 8, 8);
          
          sheets.push(sheet);
        }
        
        return sheets;
      }
      
      function createWatchtower(centerp, height, color) {
        const sheets = [];
        
        // Main tower shaft
        const shaft = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y, z: 20},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 30, h: 30}
        );
        shaft.context.fillStyle = color;
        shaft.context.fillRect(0, 0, 30, 30);
        shaft.context.strokeStyle = '#333';
        shaft.context.lineWidth = 1;
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 3; col++) {
            shaft.context.strokeRect(col * 10, row * 5, 10, 5);
            shaft.context.fillStyle = '#FFD700';
            shaft.context.fillRect(col * 10 + 3, row * 5 + 2, 4, 2);
            shaft.context.fillStyle = color;
          }
        }
        sheets.push(shaft);
        
        // Observation deck
        const deck = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y - 8, z: height + 15},
          {alphaD: 45, betaD: 0, gammaD: 0},
          {w: 45, h: 25}
        );
        deck.context.fillStyle = '#8B4513';
        deck.context.fillRect(0, 0, 45, 25);
        deck.context.strokeStyle = '#333';
        deck.context.lineWidth = 1;
        deck.context.strokeRect(2, 2, 41, 21);
        sheets.push(deck);
        
        // Spire/beacon on top
        const spire = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y, z: height + 35},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 12, h: 12}
        );
        spire.context.fillStyle = '#FF4500';
        spire.context.beginPath();
        spire.context.moveTo(6, 0);
        spire.context.lineTo(12, 10);
        spire.context.lineTo(0, 10);
        spire.context.closePath();
        spire.context.fill();
        sheets.push(spire);
        
        return sheets;
      }
      
      function createBridge(startIsland, endIsland, width = 30, color = '#8B7355') {
        const sheets = [];
        const segments = 5;
        
        for (let i = 0; i < segments; i++) {
          const ratio = i / (segments - 1);
          const x = startIsland.x + (endIsland.x - startIsland.x) * ratio;
          const y = startIsland.y + (endIsland.y - startIsland.y) * ratio;
          const z = 25;
          
          const bridgeSegment = new sheetengine.Sheet(
            {x: x, y: y, z: z},
            {alphaD: 0, betaD: 0, gammaD: 0},
            {w: 40, h: width}
          );
          
          bridgeSegment.context.fillStyle = color;
          bridgeSegment.context.fillRect(0, 0, 40, width);
          
          // Wooden planks effect
          bridgeSegment.context.strokeStyle = 'rgba(0,0,0,0.2)';
          bridgeSegment.context.lineWidth = 1;
          for (let j = 0; j < width; j += 5) {
            bridgeSegment.context.strokeRect(0, j, 40, 5);
          }
          
          // Support posts
          bridgeSegment.context.fillStyle = '#654321';
          bridgeSegment.context.fillRect(2, 2, 4, width - 4);
          bridgeSegment.context.fillRect(34, 2, 4, width - 4);
          
          sheets.push(bridgeSegment);
        }
        
        return sheets;
      }
      
      function createMarketStall(centerp, canopyColor) {
        const sheets = [];
        
        // Frame
        const frame = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y, z: 15},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 40, h: 35}
        );
        frame.context.fillStyle = '#8B4513';
        frame.context.fillRect(0, 0, 40, 30);
        frame.context.fillStyle = '#D2B48C';
        frame.context.fillRect(3, 3, 34, 8);
        frame.context.fillStyle = '#FFD700';
        frame.context.fillRect(8, 8, 8, 8);
        frame.context.fillRect(24, 8, 8, 8);
        sheets.push(frame);
        
        // Canopy top
        const canopy = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y - 10, z: 40},
          {alphaD: 45, betaD: 0, gammaD: 0},
          {w: 50, h: 30}
        );
        canopy.context.fillStyle = canopyColor;
        canopy.context.fillRect(0, 0, 50, 30);
        canopy.context.strokeStyle = '#333';
        canopy.context.lineWidth = 2;
        canopy.context.strokeRect(0, 0, 50, 30);
        sheets.push(canopy);
        
        return sheets;
      }
      
      function createHouse(centerp, roofColor, wallColor) {
        const sheets = [];
        
        // Main wall
        const wall = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y, z: 25},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 60, h: 50}
        );
        wall.context.fillStyle = wallColor;
        wall.context.fillRect(0, 0, 60, 50);
        
        // Windows with frames
        wall.context.fillStyle = '#87CEEB';
        wall.context.fillRect(8, 8, 12, 12);
        wall.context.fillRect(40, 8, 12, 12);
        wall.context.fillRect(8, 28, 12, 12);
        wall.context.fillRect(40, 28, 12, 12);
        
        // Window panes
        wall.context.strokeStyle = '#333';
        wall.context.lineWidth = 1;
        wall.context.strokeRect(8, 8, 12, 12);
        wall.context.strokeRect(40, 8, 12, 12);
        wall.context.strokeRect(8, 28, 12, 12);
        wall.context.strokeRect(40, 28, 12, 12);
        
        // Door
        wall.context.fillStyle = '#8B4513';
        wall.context.fillRect(24, 32, 12, 18);
        wall.context.fillStyle = '#FFD700';
        wall.context.fillRect(32, 40, 3, 3);
        
        sheets.push(wall);
        
        // Roof front
        const roof = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y - 15, z: 55},
          {alphaD: 45, betaD: 0, gammaD: 0},
          {w: 70, h: 40}
        );
        roof.context.fillStyle = roofColor;
        roof.context.fillRect(0, 0, 70, 40);
        
        // Roof shingles pattern
        roof.context.fillStyle = 'rgba(0,0,0,0.1)';
        for (let i = 0; i < 7; i++) {
          roof.context.fillRect(i * 10, 8, 8, 4);
          roof.context.fillRect(i * 10, 16, 8, 4);
          roof.context.fillRect(i * 10, 24, 8, 4);
        }
        
        sheets.push(roof);
        
        // Roof back
        const roofBack = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y + 15, z: 55},
          {alphaD: -45, betaD: 0, gammaD: 0},
          {w: 70, h: 40}
        );
        roofBack.context.fillStyle = roofColor;
        roofBack.context.fillRect(0, 0, 70, 40);
        
        // Roof shingles pattern
        roofBack.context.fillStyle = 'rgba(0,0,0,0.1)';
        for (let i = 0; i < 7; i++) {
          roofBack.context.fillRect(i * 10, 8, 8, 4);
          roofBack.context.fillRect(i * 10, 16, 8, 4);
          roofBack.context.fillRect(i * 10, 24, 8, 4);
        }
        
        sheets.push(roofBack);
        
        return sheets;
      }
      
      function createCharacter(centerp, name, color) {
        const body = new sheetengine.Sheet(
          {x: 0, y: 0, z: 15},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 12, h: 16}
        );
        body.context.fillStyle = color;
        body.context.fillRect(2, 5, 8, 8);
        body.context.fillStyle = '#FFD700';
        body.context.fillRect(3, 1, 6, 4);
        // Add eyes
        body.context.fillStyle = '#000';
        body.context.fillRect(5, 2, 2, 1);
        body.context.fillRect(8, 2, 2, 1);
        
        const leg1 = new sheetengine.Sheet(
          {x: -4, y: 0, z: 4},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 6, h: 10}
        );
        leg1.context.fillStyle = '#333';
        leg1.context.fillRect(1, 0, 4, 10);
        
        const leg2 = new sheetengine.Sheet(
          {x: 4, y: 0, z: 4},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 6, h: 10}
        );
        leg2.context.fillStyle = '#333';
        leg2.context.fillRect(1, 0, 4, 10);
        
        const character = new sheetengine.SheetObject(
          centerp,
          {alphaD: 0, betaD: 0, gammaD: 90},
          [body, leg1, leg2],
          {w: 80, h: 110, relu: 10, relv: 25}
        );
        
        character.name = name;
        character.color = color;
        character.leg1 = leg1;
        character.leg2 = leg2;
        
        return character;
      }
      
      function createCollectible(centerp, type, color) {
        const collectible = new sheetengine.Sheet(
          {x: centerp.x, y: centerp.y, z: centerp.z + 30},
          {alphaD: 0, betaD: 0, gammaD: 0},
          {w: 16, h: 16}
        );
        
        collectible.context.fillStyle = color;
        if (type === 'gem') {
          collectible.context.beginPath();
          collectible.context.moveTo(8, 2);
          collectible.context.lineTo(14, 6);
          collectible.context.lineTo(14, 10);
          collectible.context.lineTo(8, 14);
          collectible.context.lineTo(2, 10);
          collectible.context.lineTo(2, 6);
          collectible.context.closePath();
          collectible.context.fill();
          collectible.context.strokeStyle = '#FFD700';
          collectible.context.lineWidth = 1;
          collectible.context.stroke();
        } else if (type === 'coin') {
          collectible.context.beginPath();
          collectible.context.arc(8, 8, 6, 0, Math.PI * 2);
          collectible.context.fill();
          collectible.context.fillStyle = '#FFD700';
          collectible.context.beginPath();
          collectible.context.arc(8, 8, 4, 0, Math.PI * 2);
          collectible.context.fill();
        } else if (type === 'star') {
          collectible.context.beginPath();
          collectible.context.moveTo(8, 2);
          for (let i = 0; i < 10; i++) {
            const radius = i % 2 === 0 ? 6 : 3;
            const angle = (i * Math.PI) / 5 - Math.PI / 2;
            const x = 8 + radius * Math.cos(angle);
            const y = 8 + radius * Math.sin(angle);
            if (i === 0) collectible.context.moveTo(x, y);
            else collectible.context.lineTo(x, y);
          }
          collectible.context.closePath();
          collectible.context.fill();
        }
        
        collectible.collected = false;
        return collectible;
      }
      
      // ===== BUILD THE WORLD =====
      
      // Central island structures
      createTower({x: 0, y: 0, z: 20}, 100, '#CD5C5C', 5);     // Red tower
      createWall({x: -150, y: -150, z: 20}, {x: -150, y: 150, z: 20}, 30, '#8B7355');
      createWall({x: -150, y: 150, z: 20}, {x: 150, y: 150, z: 20}, 30, '#8B7355');
      createWall({x: 150, y: 150, z: 20}, {x: 150, y: -150, z: 20}, 30, '#8B7355');
      createWall({x: 150, y: -150, z: 20}, {x: -150, y: -150, z: 20}, 30, '#8B7355');
      
      // Houses around central tower
      createHouse({x: -80, y: -80, z: 20}, '#DC143C', '#D2B48C');
      createHouse({x: 80, y: -80, z: 20}, '#4169E1', '#D2B48C');
      createHouse({x: -80, y: 80, z: 20}, '#228B22', '#D2B48C');
      createHouse({x: 80, y: 80, z: 20}, '#FFD700', '#D2B48C');
      
      // Market stalls around town square
      createMarketStall({x: -30, y: -30, z: 20}, '#FF6347');
      createMarketStall({x: 30, y: -30, z: 20}, '#1E90FF');
      createMarketStall({x: -30, y: 30, z: 20}, '#FFD700');
      createMarketStall({x: 30, y: 30, z: 20}, '#98FB98');
      
      // Watchtowers at corners
      createWatchtower({x: -120, y: -120, z: 0}, 50, '#696969');
      createWatchtower({x: 120, y: -120, z: 0}, 50, '#696969');
      createWatchtower({x: -120, y: 120, z: 0}, 50, '#696969');
      createWatchtower({x: 120, y: 120, z: 0}, 50, '#696969');
      
      // West island structures
      createTower({x: -600, y: -300, z: 20}, 60, '#4CAF50', 3);
      createHouse({x: -650, y: -250, z: 20}, '#8B4513', '#F5DEB3');
      createMarketStall({x: -600, y: -250, z: 20}, '#FFB6C1');
      createWatchtower({x: -650, y: -350, z: 0}, 40, '#696969');
      
      // East island structures
      createTower({x: 600, y: -300, z: 20}, 80, '#1E90FF', 4);
      createHouse({x: 550, y: -300, z: 20}, '#FF6347', '#F5DEB3');
      createMarketStall({x: 600, y: -250, z: 20}, '#9370DB');
      createWatchtower({x: 650, y: -350, z: 0}, 40, '#696969');
      
      // South platform - sky port
      createHouse({x: 0, y: 500, z: 20}, '#FFD700', '#D2B48C');
      createMarketStall({x: -50, y: 500, z: 20}, '#FF4500');
      createMarketStall({x: 50, y: 500, z: 20}, '#20B2AA');
      
      // North platform - observatory
      createTower({x: 0, y: -500, z: 20}, 70, '#C0C0C0', 3);
      createHouse({x: -40, y: -480, z: 20}, '#DDA0DD', '#F5DEB3');
      createHouse({x: 40, y: -480, z: 20}, '#87CEEB', '#F5DEB3');
      
      // ===== ADD BRIDGES CONNECTING ISLANDS =====
      createBridge({x: 0, y: 0}, {x: -600, y: -300}, 25, '#8B7355');      // Central to West
      createBridge({x: 0, y: 0}, {x: 600, y: -300}, 25, '#8B7355');       // Central to East
      createBridge({x: 0, y: 0}, {x: 0, y: 500}, 25, '#8B7355');          // Central to South
      createBridge({x: 0, y: 0}, {x: 0, y: -500}, 25, '#8B7355');         // Central to North
      
      // ===== CREATE COLLECTIBLES =====
      
      const collectibles = [];
      collectibles.push(createCollectible({x: -100, y: -100, z: 0}, 'gem', '#FF69B4'));
      collectibles.push(createCollectible({x: 50, y: 50, z: 0}, 'coin', '#FFD700'));
      collectibles.push(createCollectible({x: -80, y: 100, z: 0}, 'star', '#FFD700'));
      collectibles.push(createCollectible({x: 100, y: -80, z: 0}, 'gem', '#00FF00'));
      collectibles.push(createCollectible({x: 0, y: 0, z: 0}, 'coin', '#FFD700'));
      collectibles.push(createCollectible({x: -600, y: -300, z: 0}, 'star', '#FF6347'));
      collectibles.push(createCollectible({x: 600, y: -300, z: 0}, 'gem', '#1E90FF'));
      collectibles.push(createCollectible({x: 0, y: 500, z: 0}, 'coin', '#FFD700'));
      collectibles.push(createCollectible({x: 0, y: -500, z: 0}, 'star', '#C0C0C0'));
      
      // Important structure locations for lighting effects
      const lightSources = [
        {pos: {x: 0, y: 0}, color: '#FF6347', radius: 60},      // Central tower
        {pos: {x: -600, y: -300}, color: '#FFD700', radius: 40}, // West tower
        {pos: {x: 600, y: -300}, color: '#87CEEB', radius: 40},  // East tower
        {pos: {x: 0, y: -500}, color: '#C0C0C0', radius: 35}     // North obs
      ];

      // ===== CREATE CHARACTERS =====
      
      const player = createCharacter({x: -100, y: -100, z: 0}, 'Player', '#FF1493');
      const npc1 = createCharacter({x: 80, y: 80, z: 0}, 'NPC1', '#00CED1');
      const npc2 = createCharacter({x: -600, y: -300, z: 0}, 'NPC2', '#32CD32');
      const npc3 = createCharacter({x: 600, y: -300, z: 0}, 'NPC3', '#FF8C00');
      const npc4 = createCharacter({x: 0, y: 0, z: 0}, 'Guard', '#4169E1');
      const npc5 = createCharacter({x: -80, y: -80, z: 0}, 'Merchant', '#FFD700');
      const npc6 = createCharacter({x: 80, y: 80, z: 0}, 'Scholar', '#DDA0DD');
      const npc7 = createCharacter({x: 0, y: 500, z: 0}, 'Pilot', '#20B2AA');

      // ===== GAME STATE =====
      
      let playerTarget = null;
      let hoveredObject = null;
      let score = 0;
      let collectedCount = 0;
      const npcTargets = [npc1, npc2, npc3, npc4, npc5, npc6, npc7];
      
      // Random waypoints for NPCs
      const waypoints = [
        {x: 0, y: 0, z: 0},
        {x: -600, y: -300, z: 0},
        {x: 600, y: -300, z: 0},
        {x: 0, y: 500, z: 0},
        {x: 0, y: -500, z: 0},
        {x: -100, y: -100, z: 0},
        {x: -80, y: 80, z: 0},
        {x: 80, y: -80, z: 0},
        {x: 120, y: 120, z: 0},
        {x: -120, y: -120, z: 0}
      ];
      
      npc1.currentWaypoint = 0;
      npc2.currentWaypoint = 1;
      npc3.currentWaypoint = 2;
      npc4.currentWaypoint = 3;
      npc5.currentWaypoint = 4;
      npc6.currentWaypoint = 5;
      npc7.currentWaypoint = 6;
      
      function animateCharacter(character) {
        const state = Math.floor((character.animationState % 8) / 2);
        const dir = (state == 0 || state == 3) ? 1 : -1;
        character.rotateSheet(character.leg1, {x:0,y:0,z:8}, {x:1,y:0,z:0}, dir * Math.PI/8);
        character.rotateSheet(character.leg2, {x:0,y:0,z:8}, {x:1,y:0,z:0}, -dir * Math.PI/8);
      }
      
      function drawGlowEffect(ctx, x, y, radius, color, opacity = 0.3) {
        ctx.save();
        ctx.globalAlpha = opacity;
        
        // Multiple rings for glow
        for (let i = 3; i > 0; i--) {
          ctx.fillStyle = color;
          ctx.globalAlpha = opacity / (4 - i);
          ctx.beginPath();
          ctx.arc(x, y, radius + (3 - i) * 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      function drawShadow(ctx, x, y, width, height, opacity = 0.2) {
        ctx.save();
        ctx.fillStyle = '#000';
        ctx.globalAlpha = opacity;
        ctx.fillRect(x - width/2, y, width, height/3);
        ctx.restore();
      }

      // Initial draw
      sheetengine.calc.calculateAllSheets();
      sheetengine.drawing.drawScene(true);

      // ===== EVENT HANDLING =====
      
      canvasElement.onclick = function(event) {
        const puv = {
          u: event.clientX - sheetengine.canvas.offsetLeft,
          v: event.clientY - sheetengine.canvas.offsetTop
        };
        
        // Check for object clicks
        let objectClicked = false;
        const objects = [npc1, npc2, npc3];
        for (let i = 0; i < objects.length; i++) {
          const obj = objects[i];
          const ouv = sheetengine.drawing.getPointuv(obj.centerp);
          if (puv.u > ouv.u - 20 && puv.u < ouv.u + 20 &&
              puv.v > ouv.v - 25 && puv.v < ouv.v + 25) {
            // NPC clicked - swap with player or move away
            const temp = {x: player.centerp.x, y: player.centerp.y};
            player.centerp = {x: obj.centerp.x, y: obj.centerp.y, z: 0};
            obj.centerp = {x: temp.x, y: temp.y, z: 0};
            objectClicked = true;
            break;
          }
        }
        
        if (!objectClicked) {
          // Terrain clicked - set player target
          const pxy = sheetengine.transforms.inverseTransformPoint({
            u: puv.u + sheetengine.scene.center.u,
            v: puv.v + sheetengine.scene.center.v
          });
          
          const angle = -Math.atan2(pxy.y - player.centerp.y, pxy.x - player.centerp.x) + Math.PI/2;
          player.setOrientation({alpha: 0, beta: 0, gamma: angle});
          playerTarget = pxy;
        }
      };
      
      canvasElement.onmousemove = function(event) {
        const puv = {
          u: event.clientX - sheetengine.canvas.offsetLeft,
          v: event.clientY - sheetengine.canvas.offsetTop
        };
        
        let newHover = null;
        const objects = [npc1, npc2, npc3];
        for (let i = 0; i < objects.length; i++) {
          const obj = objects[i];
          const ouv = sheetengine.drawing.getPointuv(obj.centerp);
          if (puv.u > ouv.u - 20 && puv.u < ouv.u + 20 &&
              puv.v > ouv.v - 25 && puv.v < ouv.v + 25) {
            newHover = obj;
            break;
          }
        }
        
        if (newHover !== hoveredObject) {
          hoveredObject = newHover;
        }
      };

      // ===== MAIN GAME LOOP =====
      
      function mainloop() {
        let sceneChanged = false;
        
        // Move player towards target
        if (playerTarget) {
          const dx = playerTarget.x - player.centerp.x;
          const dy = playerTarget.y - player.centerp.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 5) {
            const speed = 3;
            const moveX = (dx / dist) * speed;
            const moveY = (dy / dist) * speed;
            player.move({x: moveX, y: moveY, z: 0});
            animateCharacter(player);
            player.animationState++;
            sceneChanged = true;
          } else {
            playerTarget = null;
          }
        }
        
        // Check collectible collection
        for (let i = collectibles.length - 1; i >= 0; i--) {
          const collectible = collectibles[i];
          if (!collectible.collected) {
            const dx = collectible.centerp.x - player.centerp.x;
            const dy = collectible.centerp.y - player.centerp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 30) {
              collectible.collected = true;
              score += 10;
              collectedCount++;
              collectibles.splice(i, 1);
              sceneChanged = true;
            }
          }
        }
        
        // Move NPCs to waypoints
        for (let i = 0; i < npcTargets.length; i++) {
          const npc = npcTargets[i];
          const waypoint = waypoints[npc.currentWaypoint];
          
          const dx = waypoint.x - npc.centerp.x;
          const dy = waypoint.y - npc.centerp.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 10) {
            const speed = 2;
            const angle = -Math.atan2(dy, dx) + Math.PI/2;
            npc.setOrientation({alpha: 0, beta: 0, gamma: angle});
            
            const moveX = (dx / dist) * speed;
            const moveY = (dy / dist) * speed;
            npc.move({x: moveX, y: moveY, z: 0});
            animateCharacter(npc);
            npc.animationState++;
            sceneChanged = true;
          } else {
            npc.currentWaypoint = (npc.currentWaypoint + 1) % waypoints.length;
          }
        }
        
        if (sceneChanged) {
          sheetengine.calc.calculateChangedSheets();
          sheetengine.drawing.drawScene();
          
          const ctx = sheetengine.context;
          
          // Draw light source effects on key structures (before other overlays)
          for (let i = 0; i < lightSources.length; i++) {
            const light = lightSources[i];
            const puv = sheetengine.drawing.getPointuv(light.pos);
            // Pulsing glow
            const pulse = 0.5 + Math.sin(Date.now() / 1000 + i) * 0.3;
            drawGlowEffect(ctx, puv.u, puv.v, light.radius * pulse, light.color, 0.15 * pulse);
          }
          
          // Draw shadows for characters
          for (let i = 0; i < npcTargets.length; i++) {
            const npc = npcTargets[i];
            const puv = sheetengine.drawing.getPointuv(npc.centerp);
            drawShadow(ctx, puv.u, puv.v + 25, 30, 12, 0.25);
          }
          const playeruv = sheetengine.drawing.getPointuv(player.centerp);
          drawShadow(ctx, playeruv.u, playeruv.v + 25, 30, 12, 0.25);
          
          // Draw collectibles with glow and rotation
          for (let i = 0; i < collectibles.length; i++) {
            const collectible = collectibles[i];
            const puv = sheetengine.drawing.getPointuv(collectible.centerp);
            
            // Draw glow
            if (i % 3 === 0) drawGlowEffect(ctx, puv.u, puv.v, 12, '#FF69B4', 0.4);
            else if (i % 3 === 1) drawGlowEffect(ctx, puv.u, puv.v, 12, '#FFD700', 0.4);
            else drawGlowEffect(ctx, puv.u, puv.v, 12, '#00FF00', 0.4);
            
            ctx.save();
            
            // Spinning animation with floating effect
            const rotation = (Date.now() / 20 + i * 20) % 360;
            const float = Math.sin(Date.now() / 1000 + i) * 3;
            ctx.translate(puv.u, puv.v + float);
            ctx.rotate((rotation * Math.PI) / 180);
            ctx.fillStyle = collectible.context.fillStyle;
            ctx.fillRect(-6, -6, 12, 12);
            ctx.restore();
          }
          
          // Draw target marker with enhanced animation
          if (playerTarget) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = '#FFD700';
            const puv = sheetengine.drawing.getPointuv(playerTarget);
            
            // Outer rotating circle
            ctx.save();
            ctx.translate(puv.u, puv.v);
            ctx.rotate((Date.now() / 1000) * Math.PI);
            ctx.strokeRect(-10, -10, 20, 20);
            ctx.restore();
            
            // Inner pulsing circle
            ctx.lineWidth = 1;
            const pulseSize = 4 + Math.sin(Date.now() / 300) * 3;
            ctx.beginPath();
            ctx.arc(puv.u, puv.v, pulseSize, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
          
          // Draw hover indicator with enhanced effect
          if (hoveredObject) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = '#00FF00';
            const ouv = sheetengine.drawing.getPointuv(hoveredObject.centerp);
            ctx.strokeRect(ouv.u - 25, ouv.v - 30, 50, 50);
            ctx.fillStyle = '#00FF00';
            ctx.globalAlpha = 0.15;
            ctx.fillRect(ouv.u - 25, ouv.v - 30, 50, 50);
            
            // Draw name above NPC
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(hoveredObject.name, ouv.u, ouv.v - 35);
            ctx.restore();
          }
          
          // Draw UI - Score and collectibles with enhanced styling
          ctx.save();
          ctx.font = 'bold 18px sans-serif';
          ctx.fillStyle = '#000';
          ctx.globalAlpha = 0.9;
          ctx.fillRect(8, 8, 280, 75);
          
          // Glow effect for UI background
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.3;
          ctx.strokeRect(8, 8, 280, 75);
          
          // Main text with shadow
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0,0,0,0.7)';
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          ctx.font = 'bold 16px sans-serif';
          ctx.fillText(`‚≠ê Score: ${score}  |  üíé Treasures: ${collectedCount}/9`, 20, 32);
          
          // Draw progress bar
          const progressWidth = ((collectedCount / 9) * 240);
          ctx.fillStyle = 'rgba(255,215,0,0.3)';
          ctx.fillRect(20, 48, 240, 14);
          
          // Rainbow progress effect
          const gradient = ctx.createLinearGradient(20, 48, 260, 48);
          gradient.addColorStop(0, '#FF6347');
          gradient.addColorStop(0.5, '#FFD700');
          gradient.addColorStop(1, '#00FF00');
          ctx.fillStyle = gradient;
          ctx.fillRect(20, 48, progressWidth, 14);
          
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 48, 240, 14);
          ctx.restore();
          
          // Draw ambient particles with parallax effect
          ctx.save();
          ctx.globalAlpha = 0.25;
          for (let i = 0; i < 6; i++) {
            const x = Math.sin(Date.now() / (1000 + i * 200) + i) * 100 + 500;
            const y = Math.cos(Date.now() / (800 + i * 150) + i) * 80 + 300;
            ctx.fillStyle = i % 2 === 0 ? '#FFD700' : '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y, 1 + (i % 3), 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
          
          // Draw wind particles from movement
          if (playerTarget) {
            const distance = Math.sqrt(
              Math.pow(playerTarget.x - player.centerp.x, 2) + 
              Math.pow(playerTarget.y - player.centerp.y, 2)
            );
            if (distance > 5) {
              for (let i = 0; i < 3; i++) {
                const angle = Math.atan2(
                  playerTarget.y - player.centerp.y,
                  playerTarget.x - player.centerp.x
                );
                const particleX = player.centerp.x + Math.cos(angle + i * (Math.PI / 1.5)) * 15;
                const particleY = player.centerp.y + Math.sin(angle + i * (Math.PI / 1.5)) * 15;
                const puv = sheetengine.drawing.getPointuv({x: particleX, y: particleY, z: 5});
                
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(puv.u, puv.v, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }
      }

      setInterval(mainloop, 30);
    </script>

  </body>
</html>
